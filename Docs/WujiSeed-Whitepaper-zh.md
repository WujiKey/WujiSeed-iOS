# WujiSeed: 基于可记忆信息的确定性助记词生成与门限恢复协议

**版本:** 1.0
**发布日期:** 2026年1月
**协议版本:** WUJI-Key-V1

---

## 摘要

传统加密货币钱包所依赖的BIP39助记词作为资产访问凭证，用户必须安全存储24个随机单词。这种设计面临两难困境：物理备份易丢失或被盗，而记忆随机词序列对普通用户几乎不可能。本文提出WujiSeed协议，一种将用户**可记忆信息**（个人标识、地理位置、关联记忆）转换为确定性BIP39助记词的密码学方案。

协议采用BLAKE2b生成盐值对抗彩虹表攻击、Argon2id进行密钥派生抵抗GPU/ASIC攻击、使用F9Grid网格系统解决GPS误差导致的网格漂移，同时引入WujiTimeCapsule加密备份提供额外的记忆容错。安全性分析表明，在中等假设下协议提供约 **266 bits** 的调整熵（保守假设 216 bits，乐观假设 316 bits），即使攻击者已知部分信息，剩余熵仍远超 128-bit 安全边界。

**关键词:** 助记词生成、密钥派生、F9Grid、记忆容错、Argon2id、BIP39

---

## 1. 引言

### 1.1 问题背景

自 2013 年 BIP39 标准发布以来，助记词已成为加密货币钱包的主流密钥管理方案。用户通过 12-24 个英文单词即可恢复钱包的全部资产。然而，这一设计将安全责任完全转移给用户：

- **物理备份风险**：纸质备份可能被火灾、水灾损毁，或被入室盗窃者获取
- **数字存储风险**：云端存储面临黑客攻击，本地存储面临设备损坏
- **记忆困难**：24 个无关联随机单词的记忆难度极高，遗忘率很高
- **继承问题**：用户去世后，家属难以找回

据 Chainalysis 估计，约 20% 的比特币（价值超过 1400 亿美元）因助记词丢失而永久锁定。

### 1.2 现有方案的局限

**Brain Wallet（脑钱包）**

早期方案允许用户使用自选密码生成私钥。然而，用户选择的密码熵值普遍偏低，大规模彩虹表攻击导致大量资产被盗。2015 年后该方案已被业界废弃。

**Shamir's Secret Sharing（秘密分享）**

SLIP-39 等标准将助记词拆分为多个份额，需要 M-of-N 份额才能恢复。该方案解决了单点故障问题，但仍需物理存储份额，且增加了管理复杂度。对普通个人用户的友好度降低。

**硬件钱包**

Ledger、Trezor 等设备将私钥存储在安全芯片中。然而用户仍需备份恢复助记词，硬件故障时面临同样的恢复问题。

### 1.3 本协议的贡献

WujiSeed 协议提出了一种新的范式：

> **用你能记住的，生成你无法记住的。**

核心贡献包括：

1. **基于记忆的确定性生成**：将个人标识 + 5 个地理位置及相关记忆转换为 BIP39 助记词，相同输入始终产生相同输出

2. **高熵输入设计**：通过 F9Grid 地理编码和结构化记忆文本，确保输入空间达到 274+ bits

3. **3-of-5 门限恢复**：加密备份采用 C(5,3)=10 个独立密文块，遗忘 2 个地点仍可恢复

4. **抗暴力破解**：Argon2id 内存硬化确保单次尝试需 256MB 内存和 3-5 秒计算时间

5. **完全离线**：所有运算在用户设备本地完成，全程离线

### 1.4 文档结构

本文其余部分组织如下：第 2 节介绍协议概览和数据流；第 3 节详述密码学原语；第 4 节定义数据结构和编码规则；第 5 节描述助记词生成算法；第 6 节阐述加密备份和门限恢复机制；第 7 节进行安全性分析；第 8 节讨论限制与未来工作；附录提供测试向量和实现检查表。

---

## 2. 协议概览

### 2.1 系统模型

WujiSeed 协议涉及以下实体：

- **用户 (User)**：持有个人记忆信息，希望生成和恢复助记词
- **客户端应用 (Client)**：运行在用户设备上的离线应用程序
- **加密备份 (Backup)**：可选的加密文件，支持门限恢复

```
┌─────────────────────────────────────────────────────────────────┐
│                         用户输入层                               │
├─────────────────────────────────────────────────────────────────┤
│  ┌───────────────┐    ┌───────────────────────────────────────┐ │
│  │  个人标识      │    │  5 个地理位置                          │ │
│  │  (姓名/邮箱)   │    │  每个位置包含:                         │ │
│  │               │    │  - GPS 坐标 (经纬度)                   │ │
│  │               │    │  - 记忆关键词标签 (至少3个)             │ │
│  └───────┬───────┘    └───────────────────┬───────────────────┘ │
│          │                                │                      │
│          ▼                                ▼                      │
│  ┌───────────────┐    ┌───────────────────────────────────────┐ │
│  │ 文本标准化     │    │ 地理编码 + 文本标准化                   │ │
│  │ BLAKE2b-128   │    │ F9Grid CellIndex + 方位码              │ │
│  └───────┬───────┘    └───────────────────┬───────────────────┘ │
│          │                                │                      │
│          ▼                                ▼                      │
│  ┌───────────────┐    ┌───────────────────────────────────────┐ │
│  │  随机盐        │    │  密钥材料 (keyMaterial)                │ │
│  │  16 字节       │    │  按字节序排序后拼接                    │ │
│  └───────┬───────┘    └───────────────────┬───────────────────┘ │
└──────────┼────────────────────────────────┼──────────────────────┘
           │                                │
           ▼                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                       密钥派生层                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│     Argon2id(password = keyMaterials, salt = 随机盐)            │
│     参数: memory = 256 MB, iterations = 7, parallelism = 1      │
│                                                                  │
│                            │                                     │
│                            ▼                                     │
│                    ┌───────────────┐                            │
│                    │  256-bit 熵   │                            │
│                    │   (32 字节)   │                            │
│                    └───────┬───────┘                            │
└────────────────────────────┼────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                       输出层                                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│     BIP39 编码: 256 bits → 23 词 + (3 bits + 8 bits 校验) → 24 词│
│                                                                  │
│     ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐          │
│     │word1│word2│word3│ ... │    ...    │word23│word24│          │
│     └─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘          │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 恢复流程

协议支持两种恢复方式：

**方式一：加密备份恢复（推荐）**

```
输入: 加密备份文件, 个人标识, 任意 3-5 个地点
输出: 24 词助记词

流程:
1. 从备份文件提取 10 个加密块和方位码
2. 枚举地点组合 × 方位码组合
3. 对每个组合计算 Argon2id 密钥
4. 尝试解密所有加密块
5. 验证 BIP39 校验和
6. 返回有效助记词
```

**方式二：完全记忆恢复**

```
输入: 个人标识, 全部 5 个地点, 5 个方位码
输出: 24 词助记词

流程:
1. 直接调用生成算法
2. 依赖方位码修正 GPS 漂移
```

---

## 3. 密码学原语

### 3.1 BLAKE2b-128

**用途**：从个人标识生成 Argon2id 盐值

**算法描述**：BLAKE2b 是 BLAKE 哈希函数的优化版本，在 RFC 7693 中标准化。本协议使用 128-bit 输出变体。

**输入处理**：
```
input = UTF8(Normalize(identifier)) || UTF8("WUJI-Key-V1:Memory-Based Seed Phrases")
salt = BLAKE2b(input, outputLength=16)
```

**版本后缀的作用**：
- 确保协议升级时盐值变化，避免跨版本碰撞
- 防止其他使用 BLAKE2b 的应用产生相同盐值

**安全属性**：
- 抗碰撞：2^64 复杂度（生日攻击）
- 抗原像：2^128 复杂度

### 3.2 Argon2id

**用途**：内存硬化密钥派生，生成 256-bit 主密码

**算法选择**：Argon2 是 2015 年密码哈希竞赛 (Password Hashing Competition) 的获胜算法，在 RFC 9106 中标准化。Argon2id 变体结合了 Argon2i 的抗侧信道特性和 Argon2d 的抗 GPU 特性。

**参数配置**：

| 参数 | 值 | 说明 |
|------|-----|------|
| memory | 262144 KB (256 MB) | 内存占用 |
| iterations | 7 | 时间成本 |
| parallelism | 1 | 并行度 |
| hashLength | 32 | 输出长度 (字节) |
| version | 0x13 | Argon2 版本 1.3 |

**参数选择依据**：

1. **256 MB 内存**：现代智能手机普遍拥有 4-8 GB 内存，256 MB 在用户体验可接受范围内，同时显著提高 GPU/ASIC 攻击成本

2. **7 次迭代**：在 iPhone 12 等中端设备上耗时约 3-5 秒，平衡了安全性和用户体验

3. **单线程**：避免多核设备优势，确保所有设备计算时间一致

**安全分析**：
```
假设攻击者拥有：
- 1000 台 GPU 服务器
- 每台 256 GB 内存 (可并行 1000 个 Argon2id)
- 每秒处理 1000 × 1000 = 10^6 次尝试

攻击成本估算：
- 2^80 次尝试 / 10^6 次/秒 ≈ 10^18 秒 ≈ 3×10^10 年
```

### 3.3 XChaCha20-Poly1305

**用途**：加密备份中的助记词数据

**算法描述**：XChaCha20-Poly1305 是 ChaCha20-Poly1305 AEAD 的扩展版本，使用 192-bit nonce 消除 nonce 重用风险。

**参数**：

| 参数 | 长度 | 说明 |
|------|------|------|
| Key | 32 字节 | Argon2id 输出 |
| Nonce | 24 字节 | 每次加密随机生成 |
| Tag | 16 字节 | 认证标签 |

**安全属性**：
- 语义安全：在 CPA 模型下不可区分
- 认证性：篡改检测概率 1 - 2^-128
- Nonce 空间：2^192 消除生日碰撞风险

### 3.4 SHA-256

**用途**：BIP39 校验和计算

**算法描述**：取熵值 SHA-256 哈希的前 8 bits 作为校验和，拼接到熵值末尾后进行助记词编码。

```
checksum = SHA-256(entropy)[0:8]  // 前 8 bits
```

---

## 4. 数据结构与编码

### 4.1 文本标准化

所有用户输入文本必须经过标准化处理，确保不同输入法和设备产生一致结果。

**标准化管道**：
```
Normalize(s) = AsciiPunctNorm(CollapseWS(Trim(CaseFold(NFKC(s)))))
```

**处理步骤**：

| 步骤 | 函数 | 说明 | 示例 |
|------|------|------|------|
| 1 | NFKC | Unicode 兼容性分解后规范组合 | `ﬁ` → `fi` |
| 2 | CaseFold | Unicode 大小写折叠 | `HELLO` → `hello` |
| 3 | Trim | 去除首尾空白 | `  hello  ` → `hello` |
| 4 | CollapseWS | 合并连续空白为单个空格 | `hello   world` → `hello world` |
| 5 | AsciiPunctNorm | CJK 标点转 ASCII | `，。！` → `,.!` |

**标点映射表**：

```
全角/中文标点  →  ASCII 标点
    ，        →     ,
    。        →     .
    ！        →     !
    ？        →     ?
    ：        →     :
    ；        →     ;
   （）       →    ()
   【】       →    []
   ''        →    ''
   ""        →    ""
    ——       →     -
   ……        →    ...
```

### 4.2 WujiSpot 数据结构

每个 WujiSpot 包含三个组成部分：

```
WujiSpot = {
  place:       WujiPlace,    // 地理坐标
  memory1Tags: [String],   // 第一组记忆关键词标签（至少3个）
  memory2Tags: [String]    // 第二组记忆关键词标签（至少3个）
}

WujiPlace = {
  latitude:  Double,   // 纬度 (-90 ~ +90)
  longitude: Double    // 经度 (-180 ~ +180)
}
```

**记忆标签处理流程：**
- 每个地点有两个记忆输入区域，每个区域至少需要 3 个关键词标签
- 每个地点共需至少 6 个标签（3 + 3）
- 每个标签单独进行标准化处理（NFKC → CaseFold → Trim → AsciiPunctNorm）
- 在每个记忆区域内：标签经过去重、按 Unicode 字典序排序后，无分隔符直接拼接

### 4.3 密钥材料编码

**目的**：将地点信息转换为固定格式的二进制数据，用于密钥派生。

**编码规则**：

```
keyMaterial = sortedProcessedMemory1(UTF-8) + sortedProcessedMemory2(UTF-8) + cellIndex(8 bytes BE)
```

1. **标签标准化**：每个标签进行 (NFKC → CaseFold → Trim → AsciiPunctNorm) 处理
2. **标签去重**：在每个记忆区域内移除重复标签
3. **标签排序**：在每个记忆区域内按 Unicode 字典序排列
4. **拼接**：将排序后的标签无分隔符直接拼接，形成处理后的记忆字符串
5. **记忆排序**：两个处理后的记忆字符串按 Unicode 字典序排列（小的在前）
6. **Cell Index**：F9Grid 返回的 Int64，转换为 8 字节大端序

**示例**：

```
输入:
  memory1Tags = ["2020年", "初次旅行", "日落"]
  memory2Tags = ["东京", "樱花", "春天"]
  coordinates = (35.6762, 139.6503)

每个记忆区域内标准化并排序:
  memory1: "2020年", "初次旅行", "日落" → "2020年初次旅行日落"
  memory2: "东京", "春天", "樱花" → "东京春天樱花"

两个记忆之间排序 (Unicode字典序):
  sorted1 = "2020年初次旅行日落"  // '2' < '东'
  sorted2 = "东京春天樱花"

编码:
  keyMaterial = UTF8("2020年初次旅行日落") +
                UTF8("东京春天樱花") +
                BE64(cellIndex)
```

### 4.4 方位码

F9Grid 将每个单元格划分为 9 个子区域，编码 1-9：

```
┌───┬───┬───┐
│ 4 │ 9 │ 2 │   西北  北  东北
├───┼───┼───┤
│ 3 │ 5 │ 7 │   西   中   东
├───┼───┼───┤
│ 8 │ 1 │ 6 │   西南  南  东南
└───┴───┴───┘
```

**用途**：GPS 定位存在 10-50 米误差，可能导致坐标落入相邻单元格。方位码记录坐标在单元格内的相对位置，恢复时可据此修正偏移。

**编码方法**：5 个方位码压缩为 3 字节

```
Byte 0 = (P0 << 4) | P1
Byte 1 = (P2 << 4) | P3
Byte 2 = (P4 << 4) | 0
```

---

## 5. 助记词生成算法

### 5.1 盐值派生

```
算法 DeriveSalt(identifier)
输入: identifier - 个人标识字符串
输出: salt - 16 字节盐值

1. normalized ← Normalize(identifier)
2. input ← UTF8(normalized) || UTF8("WUJI-Key-V1:Memory-Based Seed Phrases")
3. salt ← BLAKE2b-128(input)
4. return salt
```

### 5.2 地点处理

```
算法 ProcessSpots(spots[5])
输入: spots[5] - 5 个地点记录
输出: (keyMaterials[5], positionCodes[5])

1. for i = 0 to 4:
     keyMaterials[i] ← spots[i].keyMaterial()
     positionCodes[i] ← spots[i].positionCode()

2. // 按 keyMaterial 字节序排序，positionCodes 随之重排
   (keyMaterials, positionCodes) ← sortByKeyMaterial(keyMaterials, positionCodes)

3. return (keyMaterials, positionCodes)
```

### 5.3 熵值派生

```
算法 DeriveEntropy(keyMaterials[5], salt)
输入: keyMaterials[5] - 5 个密钥材料
      salt - 16 字节盐值
输出: entropy - 32 字节熵值

1. password ← keyMaterials[0] || keyMaterials[1] || ... || keyMaterials[4]
2. entropy ← Argon2id(password, salt, memory=256MB, iterations=7)
3. return entropy
```

### 5.4 BIP39 编码

```
算法 BIP39Encode(entropy)
输入: entropy - 32 字节 (256 bits)
输出: words[24] - 24 个 BIP39 单词

1. bits ← toBinaryString(entropy)  // 256 bits

2. // 生成前 23 个单词
   for i = 0 to 22:
     index ← bitsToInt(bits[11*i : 11*(i+1)])
     words[i] ← BIP39_WORDLIST[index]

3. // 生成第 24 个单词
   remaining ← bits[253:256]                    // 剩余 3 bits
   checksum ← SHA-256(entropy)[0:8]            // 前 8 bits
   index ← bitsToInt(remaining || checksum)    // 共 11 bits
   words[23] ← BIP39_WORDLIST[index]

4. return words
```

### 5.5 完整生成流程

```
算法 GenerateMnemonic(identifier, spots[5])
输入: identifier - 个人标识
      spots[5] - 5 个地点记录
输出: (words[24], positionCodes[5])

1. salt ← DeriveSalt(identifier)
2. (keyMaterials, positionCodes) ← ProcessSpots(spots)
3. entropy ← DeriveEntropy(keyMaterials, salt)
4. words ← BIP39Encode(entropy)
5. return (words, positionCodes)
```

---

## 6. 加密备份与门限恢复

### 6.1 设计原理

为支持"仅记住 3 个地点即可恢复"，协议生成 C(5,3)=10 个独立加密块，每个块使用不同的 3 地点组合派生密钥。

**组合列表**：
```
{0,1,2} {0,1,3} {0,1,4} {0,2,3} {0,2,4}
{0,3,4} {1,2,3} {1,2,4} {1,3,4} {2,3,4}
```

### 6.2 明文格式

```
┌────────────────────────────────────┐
│  助记词数据 (33 字节)               │
│  24 词 × 11 bits = 264 bits        │
├────────────────────────────────────┤
│  随机填充 (16 字节)                 │
│  每个块使用不同的随机填充           │
└────────────────────────────────────┘
总计: 49 字节明文
```

**随机填充的作用**：
- 确保每个加密块的密文不同
- 防止攻击者通过密文比对推断组合关系

### 6.3 认证附加数据 (AAD)

```
AAD = Magic(4) + Version(1) + Options(1) + PositionCodes(3)

其中:
  Magic   = [0x57, 0x55, 0x4A, 0x49]  // "WUJI" (ASCII)
  Version = 0x01
  Options = 0x00 (保留)
  PositionCodes = 5 个方位码压缩为 3 字节
```

### 6.4 加密算法

```
算法 CreateBackup(words[24], keyMaterials[5], positionCodes[5], salt)
输入: words[24] - 24 个助记词
      keyMaterials[5] - 5 个密钥材料
      positionCodes[5] - 5 个方位码
      salt - 16 字节盐值
输出: backupData - 加密备份数据

1. mnemonicData ← WordsToBytes(words)      // 33 字节
2. sortedKM ← sort(keyMaterials)           // 按字节序排序
3. AAD ← BuildAAD(positionCodes)           // 9 字节

4. blocks ← []
5. for each combination {a, b, c} in C(5,3):
     password ← sortedKM[a] || sortedKM[b] || sortedKM[c]
     key ← Argon2id(password, salt)        // 32 字节
     padding ← RandomBytes(16)
     plaintext ← mnemonicData || padding   // 49 字节
     nonce ← RandomBytes(24)
     (ciphertext, tag) ← XChaCha20Poly1305.Encrypt(plaintext, key, nonce, AAD)
     blocks.append({nonce, ciphertext, tag})

6. shuffledBlocks ← DeterministicShuffle(blocks, sortedKM)
7. return Serialize(positionCodes, shuffledBlocks)
```

### 6.5 确定性混洗

加密块经过确定性混洗，隐藏组合与块的对应关系：

```
seed ← BLAKE2b-256(KM[0] || "|" || KM[1] || ... || "|block-shuffle-seed")
shuffled ← FisherYates(blocks, seed)
```

### 6.6 恢复算法

```
算法 RecoverFromBackup(backup, spots[N], allPositionCodes[5], salt)
输入: backup - 加密备份数据
      spots[N] - N 个地点 (3 ≤ N ≤ 5)
      allPositionCodes[5] - 5 个方位码
      salt - 16 字节盐值
输出: words[24] 或 失败

1. spotCombos ← C(N, 3)
2. posCodeCombos ← C(5, 3) = 10
3. passwordCache ← {}  // 避免重复计算

4. for each spotCombo in spotCombos:
     for each posCodeCombo in posCodeCombos:
       selectedSpots ← spots[spotCombo]
       selectedCodes ← allPositionCodes[posCodeCombo]
       keyMaterials ← ProcessSpots(selectedSpots, selectedCodes)
       password ← concat(sort(keyMaterials))

       if password in passwordCache:
         key ← passwordCache[password]
       else:
         key ← Argon2id(password, salt)
         passwordCache[password] ← key

       for each block in backup.blocks:
         plaintext ← TryDecrypt(block, key, AAD)
         if success and ValidChecksum(plaintext):
           return BytesToWords(plaintext[0:33])

5. return 失败
```

**Argon2id 调用次数**：

| 已知地点数 | 最大尝试次数 |
|-----------|-------------|
| 3 | 1 × 10 = 10 |
| 4 | 4 × 10 = 40 |
| 5 | 10 × 10 = 100 |

实际调用次数因密码缓存而减少。

---

## 7. 安全性分析

### 7.1 威胁模型

本协议考虑以下威胁场景：

**攻击者能力**：
- 获取加密备份文件
- 知道用户的个人标识
- 通过社交工程获取部分地点信息
- 拥有大规模计算资源（GPU 集群、ASIC）

**攻击者限制**：
- 无法访问用户设备内存
- 至少 3 个地点对攻击者保密
- 无法突破密码学原语

### 7.2 熵值评估

本节对协议输入的熵值进行严格分析，区分**理论熵**（理想随机选择）和**调整熵**（考虑实际使用模式）。

#### 7.2.1 F9Grid 地理位置熵

**基础数据**：
- F9Grid 全球单元格总数：300,626,092,560 个
- 单个位置理论熵：log₂(300,626,092,560) = **38.1 bits**

**调整依据**：用户不会从全球随机选择位置，而是从人类高度活跃区域选择。假设人类高度活跃区域（城市、城镇、旅游景点、交通沿线）占地球表面的 **0.2%**。

```
调整计算:
活跃区域单元格数 = 300,626,092,560 × 0.2% = 601,252,185
单个位置调整熵 = log₂(601,252,185) = 29.2 bits
```

| 项目 | 理论熵 | 调整熵 | 调整依据 |
|------|--------|--------|---------|
| 单个 F9Grid 位置 | 38.1 bits | 29.2 bits | 0.2% 人类高度活跃区域 |
| 5 个位置 (独立) | 190.5 bits | 146 bits | 各位置独立选择 |
| 5 个位置 (含相关性) | 190.5 bits | **116 bits** | 见下方相关性计算 |

**地理相关性计算**：

用户选择的 5 个地点往往存在地理聚集性，而非全球随机分布：
- 多数人长期生活在 2-3 个城市
- 童年、求学、工作地点可能集中在有限区域
- 旅行目的地也常有区域偏好

**基于搜索空间的严格推导**：

```
全球活跃区域网格数:
  300,626,092,560 × 0.2% = 601,252,185 个

普通用户可选区域 (2-3个以上城市，约占活跃区域的 1-2%):
  取中值 1.5%: 601,252,185 × 1.5% = 9,018,783 个

单个位置调整熵:
  log₂(9,018,783) = 23.1 bits

5 个位置 (独立选择):
  23.1 × 5 = 115.5 bits ≈ 116 bits
```

**不同用户类型的熵估算**：

| 用户类型 | 可选区域占比 | 可选网格数 | 单位置熵 | 5 位置熵 |
|---------|-------------|-----------|---------|---------|
| 全球旅行者 | 100% | 6.0×10^8 | 29.2 bits | 146 bits |
| 普通用户 | 1-2% | 9.0×10^6 | 23.1 bits | **116 bits** |
| 单城市居民 | 0.3-0.5% | 2.4×10^6 | 21.2 bits | 106 bits |

本协议采用 **普通用户（1-2% 活跃区域）** 作为保守估计。

#### 7.2.2 记忆标签熵

每个地点有 2 个记忆区域，每区域至少 3 个关键词标签。5 个地点共 10 个记忆片段。

**关键认知**：同一记忆区域内的 3 个标签描述的是**同一个记忆事件**，它们之间存在强相关性。例如 "2020年"、"妈妈"、"生日" 共同描述一个事件，攻击者若猜中其一，其余两个的搜索空间大幅缩小。因此，应以**记忆事件**为单位评估熵值，而非简单地将标签熵值相乘。

**记忆事件搜索空间分析**：

攻击者需要猜测用户选择了哪些记忆事件。一个人一生中可被选择的显著记忆事件数量取决于：
- 事件类型：生日、旅行、毕业、婚礼、约会、纪念日、聚会、工作成就等
- 时间跨度：用户的年龄和记忆深度
- 关联人物：家人、朋友、同事、恋人等
- 细节变体：同类事件的不同实例

**记忆事件熵值评估**：

| 搜索空间规模 | 熵值 | 说明 |
|-------------|------|------|
| ~1,000 事件 | 10 bits | 保守：一生中约1000个显著记忆 |
| ~10,000 事件 | 13 bits | 中等：包含更多细节变体 |
| ~100,000 事件 | 17 bits | 乐观：非常详尽的个人记忆库 |

**三种评估场景**（5 个地点 × 2 个记忆区域 = 10 个记忆事件）：

| 场景 | 假设 | 单事件熵 | 10 事件熵 |
|------|------|----------|----------|
| **保守** | 攻击者能枚举约1000种常见记忆模式 | 10 bits | 100 bits |
| **中等** | 攻击者能枚举约10000种记忆模式 | 13 bits | 130 bits |
| **乐观** | 攻击者能枚举约10万种记忆模式 | 17 bits | 170 bits |

本协议采用 **中等场景（13 bits/事件）** 作为默认评估标准。

**标签系统的优势**：
- 关键词格式统一，减少了表述变体带来的不确定性
- 用户更容易准确回忆离散的关键词
- 强制至少 3 个标签，确保记忆描述的最小信息量

#### 7.2.3 个人标识熵

个人标识（姓名、身份证件、邮箱等）用于生成 BLAKE2b 盐值，具有两重安全作用：

**作用 1：防止彩虹表攻击**
- 即使攻击者已知用户身份，盐值仍确保无法使用预计算表
- 不同用户相同地点产生不同密钥

**作用 2：非定向攻击时提供额外熵**

当攻击者进行非定向攻击（如：获取大量加密备份但不知道具体用户身份）时，个人标识成为额外的搜索空间：

| 标识类型 | 可能值 | 额外熵 |
|---------|--------|--------|
| 姓名（全名） | ~10^8 | ~27 bits |
| 身份证件号码 | ~10^10 | ~33 bits |
| 电子邮箱 | ~10^9 | ~30 bits |
| 手机号码 | ~10^10 | ~33 bits |
| 自定义字符串 | 可变 | 10-50 bits |

**注意**：用户可使用多个标识的组合（如"姓名+手机号"），进一步增加搜索空间。例如，姓名（~27 bits）与手机号（~33 bits）组合可达 ~60 bits 额外熵。

**熵值计算策略**：

| 攻击类型 | 个人标识熵 | 说明 |
|---------|-----------|------|
| 定向攻击 | 0 bits | 攻击者已知目标身份，无需猜测个人标识 |
| 非定向攻击（单一标识） | 27-33 bits | 攻击者需猜测用户使用的标识类型和具体值 |
| 非定向攻击（组合标识） | 50-60+ bits | 用户使用多个标识组合，搜索空间指数级增长 |

**定向攻击**：攻击者针对特定已知目标（如公开人物、已泄露信息的用户），个人标识对攻击者透明，不提供额外保护。本协议的基准安全评估采用此最坏情况假设。

**非定向攻击**：攻击者获取大量加密备份但不知道具体用户身份（如数据泄露事件），必须同时猜测：
- 标识类型（姓名？邮箱？手机号？证件号？）
- 具体标识值（哪个姓名？哪个号码？）
- 可能的组合方式

此时个人标识成为有效的安全屏障，协议可额外获得 **27-60+ bits** 的安全裕度。

#### 7.2.4 加密备份熵

加密备份采用 3-of-5 门限方案，生成 C(5,3)=10 个独立加密块。攻击者面临以下熵源：

**3 地点组合熵**：

攻击者需猜测用于解密的 3 个地点及其记忆事件（每地点 2 个记忆事件，共 6 个事件）：
```
位置熵: 23.1 × 3 = 69.3 bits
记忆熵: 13 × 6 = 78 bits (中等场景)
组合熵: 69.3 + 78 ≈ 147 bits
```

**顺序混洗熵**：

10 个加密块经过确定性混洗（见 6.5 节），隐藏组合与块的对应关系：
```
混洗排列数: 10! = 3,628,800
混洗熵: log₂(10!) ≈ 21.8 bits
```

攻击者不知道哪个块对应哪个 3 地点组合，必须对每个猜测的组合尝试所有 10 个块。

**加密备份总熵**：

| 熵源 | 熵值 | 说明 |
|------|------|------|
| 3 地点位置 | 69.3 bits | 23.1 bits × 3 |
| 6 个记忆事件 | 78 bits | 13 bits × 6 (中等) |
| 块顺序混洗 | 21.8 bits | log₂(10!) |
| **合计** | **~169 bits** | 门限恢复攻击总熵 |

**注意**：混洗熵是"搜索成本增加"，而非独立熵源。实际攻击中，每次密钥猜测需尝试最多 10 个块，使攻击成本提高约 10 倍。

#### 7.2.5 熵值汇总

**固定部分**：

| 熵值来源 | 调整熵 | 调整方法 |
|---------|--------|---------|
| 个人标识 | 0 bits | 假设攻击者已知 |
| 5 个 F9Grid 位置 | 116 bits | 0.2% × 1.5% 可选区域 |

**三种场景下的总熵评估**（5 个地点 × 2 个记忆区域 = 10 个记忆事件）：

| 场景 | 事件熵假设 | 10 事件熵 | 位置熵 | **总调整熵** |
|------|-----------|----------|--------|-------------|
| **保守** | 10 bits/事件 | 100 bits | 116 bits | **216 bits** |
| **中等** | 13 bits/事件 | 130 bits | 116 bits | **246 bits** |
| **乐观** | 17 bits/事件 | 170 bits | 116 bits | **286 bits** |

本协议采用 **中等场景（246 bits）** 作为安全评估基准。

**结论**：即使采用更保守的"记忆事件"级别熵值评估（考虑标签间相关性），协议在保守假设下（216 bits）仍提供远超 128-bit 的安全边界。中等场景下的 246 bits 调整熵足以抵御可预见的暴力破解攻击。

### 7.3 攻击成本分析

以下分析基于**中等场景（246 bits 总熵）**，采用"记忆事件"级别的熵值评估。

**场景 1：完全暴力破解**

攻击者不知道任何地点和记忆，需要遍历所有可能：
```
调整熵: 246 bits (中等场景)
尝试次数: 2^246
Argon2id 单次: 256 MB × 3-5 秒
总成本: 远超宇宙可观测粒子数 (10^80)
```

**场景 2：已知 2 个地点及其记忆**

攻击者需要猜测剩余 3 个地点和 6 个记忆事件：
```
剩余位置熵: 23.1 × 3 = 69.3 bits
剩余记忆熵: 13 × 6 = 78 bits (中等场景)
总剩余熵: 69.3 + 78 ≈ 147 bits

尝试次数: 2^147
以 10^6 次/秒计: 2^147 / 10^6 ≈ 10^38 秒 ≈ 10^30 年
```

**场景 3：已知 2 个地点，记忆全部泄露**

最坏情况：攻击者知道所有记忆事件，仅需猜测 3 个地点：
```
剩余位置熵: 23.1 × 3 = 69.3 bits
尝试次数: 2^69.3 ≈ 10^21

以 10^6 次/秒计: 10^21 / 10^6 = 10^15 秒 ≈ 3×10^7 年
```

**场景 4：加密备份攻击（纯备份）**

攻击者仅获取加密备份文件，不知道任何地点信息，尝试破解 3-of-5 门限加密：

```
需猜测: 3 个地点 + 6 个记忆事件

位置熵: 23.1 × 3 = 69.3 bits
记忆熵: 13 × 6 = 78 bits
块遍历开销: 每次需尝试 10 个混洗后的块
总熵: 69.3 + 78 + log₂(10) ≈ 150.6 bits
```

**场景 5：加密备份攻击（部分已知）**

攻击者获取加密备份文件，且已知 2 个地点及其记忆：

```
已知: 加密备份文件 + 2 个地点 + 对应 4 个记忆事件
需猜测: 剩余 1 个地点 + 2 个记忆事件

剩余位置熵: 23.1 bits (1 个地点)
剩余记忆熵: 13 × 2 = 26 bits
块遍历开销: 每次需尝试 10 个混洗后的块
总剩余熵: 23.1 + 26 + log₂(10) ≈ 52.4 bits
```

**注意**：加密备份的安全性取决于 **"最弱的 3 地点组合"**。如果攻击者已知 2 个地点，只需再猜测 1 个地点即可解密对应的块。

**攻击成本对比（中等场景）**：

| 场景 | 剩余熵 | 尝试次数 | 破解时间 (10^6/秒) |
|------|--------|---------|-------------------|
| 完全未知 | 246 bits | 2^246 | ∞ |
| 已知 2 地点+记忆 | 147 bits | 2^147 | ~10^30 年 |
| 已知 2 地点，记忆泄露 | 69 bits | 2^69 | ~3×10^7 年 |
| 备份攻击（纯备份） | 151 bits | 2^151 × 10 | ~10^32 年 |
| 备份攻击（已知 2 地点+记忆） | 52 bits | 2^52 × 10 | ~1×10^9 年 |
| 已知 4 地点，记忆泄露 | 23 bits | 2^23 | ~8 秒 ⚠️ |

**不同假设下的安全边界**：

| 假设场景 | 总熵 | 安全评价 |
|---------|------|---------|
| 保守 | 216 bits | 超过 128-bit 安全边界 |
| 中等 | 246 bits | 超过 128-bit 安全边界 |
| 乐观 | 286 bits | 超过 256-bit 安全边界 |

**安全边界**：协议安全性依赖于**至少 3 个地点对攻击者保密**。

### 7.4 安全假设

1. **设备安全**：用户设备未被恶意软件入侵
2. **位置保密**：至少 3 个地点对攻击者保密
3. **记忆保密**：关联记忆文本对攻击者保密
4. **密码学安全**：BLAKE2b、Argon2id、XChaCha20-Poly1305 无已知漏洞

### 7.5 最佳实践建议

1. **地点选择**：
   - 避免热门公共地标（容易被猜测）
   - 选择个人独特的私密地点
   - 5 个地点应分散在不同地理区域

2. **记忆标签**：
   - 使用具体的关键词（日期、人物、事件、感受）
   - 避免使用公开信息（如社交媒体发布内容）
   - 每个记忆区域使用至少 3 个独特的标签（每地点共 6 个）
   - 可以使用超过 3 个标签以增加安全性

3. **使用环境**：
   - 开启飞行模式后再运行应用
   - 避免在公共 WiFi 环境下使用
   - 完成后清除剪贴板

4. **备份存储**：
   - 加密备份与位置提示分开存储
   - 可存储在云端（已加密，安全性不依赖存储介质）
   - 多地备份防止单点故障

---

## 8. 限制与未来工作

### 8.1 当前限制

1. **记忆稳定性**：用户对记忆文本的表述可能随时间变化，导致标准化后结果不同

2. **GPS 精度依赖**：虽然方位码可修正部分漂移，但极端 GPS 误差（>100米）可能导致恢复失败

3. **单设备恢复**：完全记忆恢复需要准确回忆所有信息，对用户记忆力要求较高

4. **无容错设计**：单个记忆文本错误即导致整体失败

### 8.2 未来工作

1. **模糊匹配**：研究容忍小范围输入偏差的密钥派生方法

2. **渐进式恢复**：设计交互式恢复流程，逐步验证用户输入

3. **多语言熵评估**：针对不同语言开发离线熵评估算法

4. **硬件集成**：与安全芯片（SE）或可信执行环境（TEE）结合

5. **标准化提案**：向 BIP 社区提交协议标准化提案

---

## 附录 A：二进制格式规范

### A.1 备份文件结构

```
┌─────────┬─────────┬─────────┬────────────────┬───────────────┐
│ Magic   │ Version │ Options │ PayloadLength  │ PositionCodes │
│ 4 bytes │ 1 byte  │ 1 byte  │ 2 bytes (BE)   │ 3 bytes       │
├─────────┴─────────┴─────────┴────────────────┴───────────────┤
│                                                               │
├─────────┬────────────────────────────────────────────────────┤
│ Count   │ Blocks[10]                                          │
│ 1 byte  │ variable                                            │
├─────────┴────────────────────────────────────────────────────┤
│                                                               │
├──────────────────────────────────────────────────────────────┤
│ CRC32                                                         │
│ 4 bytes                                                       │
└──────────────────────────────────────────────────────────────┘
```

### A.2 加密块结构

```
┌─────────────────┬─────────────┬──────────────────────┬─────────────┐
│ BlockLength     │ Nonce       │ Ciphertext           │ Tag         │
│ 2 bytes (BE)    │ 24 bytes    │ 49 bytes             │ 16 bytes    │
└─────────────────┴─────────────┴──────────────────────┴─────────────┘
每块总计: 2 + 24 + 49 + 16 = 91 字节
```

### A.3 典型文件大小

```
头部:          8 字节
方位码:        3 字节
块计数:        1 字节
10 个加密块:   91 × 10 = 910 字节
CRC32:         4 字节
─────────────────────────
总计:          926 字节
```

---

## 附录 B：测试向量

### B.1 文本标准化

```
输入:  "  HELLO  WORLD！  "
输出:  "hello world!"

处理步骤:
  NFKC:       "  HELLO  WORLD！  "
  CaseFold:   "  hello  world！  "
  Trim:       "hello  world！"
  CollapseWS: "hello world！"
  AsciiPunct: "hello world!"
```

### B.2 盐值生成

```
输入:
  identifier = "test@example.com"

计算:
  normalized = "test@example.com"
  input = "test@example.comWUJI-Key-V1:Memory-Based Seed Phrases"
  salt = BLAKE2b-128(UTF8(input))
       = [待填充具体值]
```

### B.3 BIP39 索引

```
单词 "abandon" → 索引 0    → 二进制 "00000000000"
单词 "zoo"     → 索引 2047 → 二进制 "11111111111"

24 词 × 11 bits = 264 bits = 33 字节
```

---

## 附录 C：实现检查表

- [ ] 所有整数使用大端字节序
- [ ] 所有字符串使用 UTF-8 编码
- [ ] 排序使用字节字典序比较
- [ ] 随机数使用 CSPRNG 生成
- [ ] Argon2id 使用版本 1.3 (0x13)
- [ ] 标准化管道严格按顺序执行
- [ ] 助记词验证包含 BIP39 校验和检查
- [ ] 加密后清除内存中的明文数据
- [ ] 敏感数据不写入日志或持久化存储

---

## 参考文献

[1] M. Palatinus, P. Rusnak, A. Voisine, S. Bowe, "BIP39: Mnemonic code for generating deterministic keys," Bitcoin Improvement Proposals, 2013. [Online]. Available: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki

[2] A. Biryukov, D. Dinu, D. Khovratovich, "Argon2: the memory-hard function for password hashing and other applications," RFC 9106, IETF, 2021. DOI: 10.17487/RFC9106

[3] J.-P. Aumasson, S. Neves, Z. Wilcox-O'Hearn, C. Winnerlein, "BLAKE2: simpler, smaller, fast as MD5," Applied Cryptography and Network Security, 2013. [Online]. Available: https://www.blake2.net/

[4] Y. Nir, A. Langley, "ChaCha20 and Poly1305 for IETF Protocols," RFC 8439, IETF, 2018. DOI: 10.17487/RFC8439

[5] S. Arciszewski, "XChaCha: eXtended-nonce ChaCha and AEAD_XChaCha20_Poly1305," Internet-Draft, IETF, 2020. [Online]. Available: https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha

[6] A. Shamir, "How to share a secret," Communications of the ACM, vol. 22, no. 11, pp. 612-613, 1979. DOI: 10.1145/359168.359176

[7] P. Rusnak, "SLIP-0039: Shamir's Secret-Sharing for Mnemonic Codes," SatoshiLabs Improvement Proposals, 2017. [Online]. Available: https://github.com/satoshilabs/slips/blob/master/slip-0039.md

[8] Chainalysis, "The 2024 Crypto Crime Report," 2024. [Online]. Available: https://www.chainalysis.com/

---

## 版本历史

| 版本 | 日期 | 变更 |
|------|------|------|
| 1.0 | 2024-12 | 初始白皮书发布 |
| 1.1 | 2026-01 | 将自由文本记忆改为标签输入（2 个记忆区域 × 3 个标签 = 每地点 6 个标签）；采用"记忆事件"级别的熵值评估（考虑标签间相关性） |

---

**文档结束**
