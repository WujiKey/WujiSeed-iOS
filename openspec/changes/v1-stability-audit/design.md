## 背景 (Context)

### 当前状态

WujiSeed V1 版本已经投入生产使用，核心算法流程包括：

1. **文本归一化** → NFKC → CaseFold → Trim → CollapseWS → AsciiPunctNorm
2. **盐生成** → BLAKE2b-128(Normalize(name) + "WUJI-Key-V1:Memory-Based Seed Phrases")
3. **地理编码** → F9Grid 单元格索引 + 9 宫格位置代码（1-9 布局）
4. **记忆处理** → 归一化 → 去重 → Unicode 排序 → 拼接
5. **密钥派生** → Argon2id（3 种预设：Fast/Balanced/Intensive）
6. **助记词生成** → BIP39 标准（256 位熵 → 24 个单词）
7. **加密备份** → XChaCha20-Poly1305 记忆容错机制（10 个独立加密块）

### 存在的问题

- 缺少系统化的稳定性基准文档
- 黄金测试向量的覆盖范围未经审计
- 依赖库升级路径没有兼容性验证机制
- 跨平台实现缺少一致性验证标准
- 代码重构时缺少防御性测试保障

### 约束条件

- **不能破坏向后兼容性**：已有用户的助记词和加密备份必须在新版本中正常工作
- **确定性要求**：所有算法必须是确定性的，相同输入必须产生相同输出
- **依赖库锁定**：Swift-Sodium 0.9.1 和 F9Grid 1.1.0 必须保持版本锁定
- **跨平台一致性**：iOS、Android、JavaScript 实现必须产生完全相同的结果
- **离线优先**：所有验证机制必须在本地执行，不依赖网络

### 利益相关方

- **现有用户**：依赖当前实现生成的助记词和加密备份
- **开发团队**：需要清晰的稳定性基准和测试保障
- **跨平台开发者**：需要一致性验证标准和实现指南
- **安全审计人员**：需要完整的加密算法规范和验证清单

## 目标 / 非目标 (Goals / Non-Goals)

### 目标 (Goals)

1. **建立稳定性基准**
   - 为 7 个核心算法建立明确的稳定性基准文档
   - 明确每个算法的输入输出规范和不变性保证

2. **审计测试覆盖**
   - 验证两个黄金向量（Vector 1: 西游记、Vector 2: Moses Exodus）的完整性
   - 识别测试覆盖的盲区和边界情况

3. **建立防御性测试框架**
   - 强制执行黄金向量回归测试（CI/CD 阻断）
   - 为所有 WujiLib 业务逻辑建立单元测试标准
   - 建立依赖库升级的兼容性验证流程

4. **识别兼容性风险点**
   - 审计依赖库（Swift-Sodium、F9Grid）的版本锁定机制
   - 识别平台差异（iOS 版本升级、Swift 编译器变更）可能的影响
   - 建立代码重构的兼容性检查清单

5. **建立跨平台验证机制**
   - 提供跨平台实现指南和验证清单
   - 确保黄金向量可用于所有平台的一致性验证

### 非目标 (Non-Goals)

1. **不修改现有算法实现**
   - 此次变更仅审计和验证，不改变任何加密算法逻辑
   - 不优化性能或重构代码（除非发现影响兼容性的 bug）

2. **不添加新功能**
   - 不添加新的加密算法或密钥派生方式
   - 不修改黄金向量的内容（仅验证和文档化）

3. **不改变依赖库版本**
   - Swift-Sodium 和 F9Grid 保持当前版本不变
   - 不升级到新版本（除非经过完整兼容性验证）

4. **不修改 UI 或用户体验**
   - 此次变更完全聚焦于后端算法的稳定性和测试

## 决策 (Decisions)

### 决策 1：使用黄金向量作为稳定性基准

**选择：** 将现有的两个黄金测试向量（wujikey_v1_vector_1.json、wujikey_v1_vector_2.json）作为 V1 版本的稳定性基准。

**理由：**
- 黄金向量已包含完整的中间状态数据（normalizedName、nameSaltHex、memoryProcessed、positionCode、keyDataHex、mnemonics、encryptedBackupBase64）
- 覆盖了多语言输入（中文、英文）和跨半球地理坐标
- 使用生产环境参数（Argon2id: 256MB/7 iterations）

**替代方案：**
- **方案 A**：生成更多黄金向量覆盖更多边界情况
  - ❌ 拒绝理由：两个向量已覆盖关键场景，增加向量会增加维护成本
- **方案 B**：使用单元测试代替黄金向量
  - ❌ 拒绝理由：单元测试无法验证跨平台一致性，黄金向量是跨平台验证的标准

### 决策 2：强制执行 CI/CD 黄金向量回归测试

**选择：** 在 CI/CD 流程中强制执行黄金向量回归测试，任何测试失败都阻止代码合并。

**理由：**
- 防止无意的代码更改破坏向后兼容性
- 确保每次提交都经过完整的算法验证
- 提供清晰的失败信号和可追溯的中间状态

**替代方案：**
- **方案 A**：仅在 release 分支执行回归测试
  - ❌ 拒绝理由：问题发现太晚，修复成本高
- **方案 B**：手动执行回归测试
  - ❌ 拒绝理由：容易遗漏，缺少自动化保障

### 决策 3：依赖库版本锁定策略

**选择：** 明确锁定 Swift-Sodium 0.9.1 和 F9Grid 1.1.0，升级前必须通过完整的黄金向量测试。

**理由：**
- 加密库的升级可能改变算法实现细节（如 padding、endianness）
- F9Grid 的升级可能改变地理编码算法
- 版本锁定提供确定性保证

**替代方案：**
- **方案 A**：允许自动依赖升级
  - ❌ 拒绝理由：极高风险，可能破坏所有用户的助记词恢复
- **方案 B**：Fork 依赖库到项目内部
  - ❌ 拒绝理由：维护成本高，无法获得上游安全补丁

**升级路径：**
1. 在隔离环境中测试新版本依赖
2. 运行完整的黄金向量回归测试
3. 验证所有中间状态和最终输出完全匹配
4. 如果测试失败，记录差异并评估影响
5. 仅在 100% 兼容时才升级

### 决策 4：测试架构设计

**选择：** 分层测试架构

1. **单元测试层**：每个算法模块独立测试（WujiNormalizer、CryptoUtils、WujiMemoryTagProcessor、BIP39Helper）
2. **集成测试层**：验证完整的数据转换流程（用户输入 → 助记词）
3. **回归测试层**：黄金向量端到端验证（WujiRegressionTests）

**理由：**
- 单元测试提供快速反馈和边界情况覆盖
- 集成测试验证模块间的数据流
- 回归测试确保向后兼容性

**替代方案：**
- **方案 A**：仅使用端到端测试
  - ❌ 拒绝理由：失败时难以定位问题，反馈慢
- **方案 B**：仅使用单元测试
  - ❌ 拒绝理由：无法验证完整流程的兼容性

### 决策 5：加密备份验证策略

**选择：** 验证记忆容错机制的所有 10 个独立加密块，确保任意 3 个地点都能恢复助记词。

**理由：**
- 记忆容错是 WujiSeed 的核心特性，必须确保稳定性
- 10 个加密块的确定性是跨版本兼容的关键
- 验证确定性洗牌（DeterministicShuffle）的可重现性

**验证内容：**
1. 所有 10 种 3-location 组合的加密块都存在
2. 每个块使用不同的 Argon2id 密钥派生
3. 破解任何一个块都能恢复完整助记词
4. 块的顺序经过确定性洗牌且可重现

### 决策 6：跨平台兼容性验证机制

**选择：** 提供语言无关的黄金向量 JSON 文件和详细的实现指南。

**理由：**
- JSON 格式易于在所有平台解析
- 中间状态数据允许分步验证
- 实现指南明确算法细节（如 Unicode 排序、字节序）

**跨平台验证清单：**
1. 文本归一化（NFKC → CaseFold → Trim → CollapseWS → AsciiPunctNorm）
2. BLAKE2b-128 盐生成（16 字节，后缀："WUJI-Key-V1:Memory-Based Seed Phrases"）
3. F9Grid 地理编码（包括负坐标处理）
4. 记忆标签处理（Unicode 排序规则）
5. Argon2id 密钥派生（参数和字节序）
6. BIP39 助记词生成（严格遵循标准）
7. XChaCha20-Poly1305 加密（nonce、key、AAD）

## 风险 / 权衡 (Risks / Trade-offs)

### 风险 1：黄金向量覆盖不完整

**风险描述：** 两个黄金向量可能无法覆盖所有边界情况和平台差异。

**缓解措施：**
- 增加单元测试覆盖边界情况（空字符串、极长输入、特殊字符、极端坐标）
- 文档化已知的测试覆盖范围和未覆盖的场景
- 建立社区反馈机制，收集跨平台实现中发现的问题

**权衡：** 增加更多黄金向量会增加维护成本，当前选择覆盖关键场景即可。

### 风险 2：依赖库存在未发现的 bug

**风险描述：** Swift-Sodium 0.9.1 或 F9Grid 1.1.0 可能存在影响兼容性的 bug。

**缓解措施：**
- 锁定依赖库版本，防止意外升级
- 监控上游安全公告和 bug 修复
- 建立依赖库升级的兼容性验证流程
- 如发现 bug，评估影响范围并制定修复策略

**权衡：** 版本锁定可能错过上游的性能优化和新功能，但稳定性优先。

### 风险 3：iOS 平台升级影响算法行为

**风险描述：** 新版本 iOS 系统或 Swift 编译器可能改变标准库行为（如 Unicode 归一化、字符串排序）。

**缓解措施：**
- 在新版本 iOS 上运行完整的回归测试
- 使用明确的算法实现，减少对平台标准库的依赖
- 文档化平台相关的实现细节
- 建立 iOS 版本兼容性测试矩阵

**权衡：** 减少平台依赖可能需要自己实现某些算法，增加代码复杂度。

### 风险 4：跨平台 Unicode 排序差异

**风险描述：** 不同平台的 Unicode 排序实现可能不一致（如 Swift vs Java vs JavaScript）。

**缓解措施：**
- 明确文档化 Unicode 排序规则（使用 Unicode Collation Algorithm）
- 提供参考实现和测试用例
- 在跨平台实现指南中强调排序规则的重要性
- 使用黄金向量验证跨平台一致性

**权衡：** 可能需要每个平台实现自定义的 Unicode 排序，而不是依赖标准库。

### 风险 5：测试维护成本

**风险描述：** 大量的测试用例和回归测试会增加维护成本和 CI 执行时间。

**缓解措施：**
- 优先保证黄金向量回归测试（必须执行）
- 单元测试按模块组织，支持并行执行
- 使用测试缓存机制，仅在相关代码变更时执行
- 定期审查测试用例，删除冗余测试

**权衡：** 接受更长的 CI 执行时间以换取兼容性保障。

## 迁移计划 (Migration Plan)

### 阶段 1：建立基准和审计（当前阶段）

**目标：** 建立稳定性基准文档和审计现有实现。

**步骤：**
1. 审计 7 个核心算法的实现，确认与技术规范一致
2. 验证黄金向量的完整性和覆盖范围
3. 识别缺失的单元测试和边界情况
4. 文档化 V1 版本的稳定性承诺

**验收标准：**
- 所有黄金向量测试通过
- 文档化所有关键算法的输入输出规范
- 识别所有兼容性风险点

### 阶段 2：建立防御性测试框架

**目标：** 建立完整的测试保障体系。

**步骤：**
1. 为所有 WujiLib 业务逻辑添加单元测试
2. 在 CI/CD 中集成黄金向量回归测试
3. 建立依赖库升级的验证流程
4. 建立代码审查兼容性检查清单

**验收标准：**
- WujiLib 核心算法单元测试覆盖率 > 90%
- CI/CD 强制执行回归测试
- 依赖库版本锁定机制生效

### 阶段 3：跨平台验证

**目标：** 确保跨平台实现的一致性。

**步骤：**
1. 编写跨平台实现指南
2. 提供黄金向量验证脚本
3. 建立跨平台兼容性验证流程

**验收标准：**
- 跨平台实现指南完整且可执行
- Android/JavaScript 实现通过黄金向量验证

### 回滚策略

由于此次变更仅添加测试和文档，不修改生产代码，因此不需要回滚策略。如果发现问题：

1. **测试失败**：修复测试用例或代码实现
2. **文档错误**：更新文档
3. **CI 阻断**：临时禁用特定测试（需要技术负责人批准）

## 待解决问题 (Open Questions)

### 问题 1：是否需要增加第三个黄金向量？

**描述：** 当前两个黄金向量分别覆盖中文和英文输入，是否需要增加日文/西班牙文向量？

**建议：** 暂不增加，当前覆盖已足够。可在未来根据跨平台实现反馈决定。

### 问题 2：如何处理依赖库的安全漏洞？

**描述：** 如果 Swift-Sodium 或 F9Grid 发现严重安全漏洞，但升级会破坏兼容性，如何权衡？

**建议：** 制定安全漏洞响应流程：
1. 评估漏洞影响范围
2. 如果影响 WujiSeed，优先修复（即使破坏兼容性）
3. 提供迁移工具和用户通知

### 问题 3：是否需要建立自动化的跨平台测试？

**描述：** 是否需要在 CI 中自动运行 Android/JavaScript 实现的黄金向量测试？

**建议：** 暂不需要。跨平台测试可在各平台的 CI 中独立运行，使用相同的黄金向量文件。

### 问题 4：如何处理 Unicode 标准升级？

**描述：** Unicode 标准持续演进，新版本可能改变 NFKC 归一化或排序规则。

**建议：**
1. 锁定 Unicode 版本（如 Unicode 13.0）
2. 文档化使用的 Unicode 版本
3. 升级前进行兼容性验证
